\documentclass[12pt]{article}
% generated by Madoko, version 1.2.0
%mdk-data-line={1}


\usepackage[heading-base={2},section-num={False},bib-label={hide},fontspec={True}]{madoko2}
\usepackage[left=1in,right=1in,top=1in,bottom=1in,footskip=.25in]{geometry}


\begin{document}



%mdk-data-line={16}
\mdxtitleblockstart{}
%mdk-data-line={16}
\mdxtitle{\mdline{16}Final Project Report for FA20 CSE208}%mdk
\mdxauthorstart{}
%mdk-data-line={21}
\mdxauthorname{\mdline{21}Xiaohan Fu}%mdk

%mdk-data-line={24}
\mdxauthoraddress{\mdline{24}UC San Diego}%mdk

%mdk-data-line={27}
\mdxauthoremail{\mdline{27}x5fu@ucsd.edu}%mdk
\mdxauthorend\mdtitleauthorrunning{}{}\mdxtitleblockend%mdk

%mdk-data-line={18}
\section{\mdline{18}1.\hspace*{0.5em}\mdline{18}Introduction}\label{sec-intro}%mdk%mdk

%mdk-data-line={20}
\noindent\mdline{20}In this project, my major accomplishments are:%mdk

%mdk-data-line={22}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={22}
\item\mdline{22}Exploration on multiple FHE libraries, including SEAL, Lattigo, and Palisade;%mdk

%mdk-data-line={23}
\item\mdline{23}Better understanding of \mdline{23}\mdcode{CMake}\mdline{23} and 3rd party libraries for \mdline{23}\mdcode{C++}\mdline{23};%mdk

%mdk-data-line={24}
\item\mdline{24}Implementation of an anonymous rider-driver pairing application with batching and serialization (code available\mdline{24}~\href{https://github.com/Reapor-Yurnero/obliviousRiding_SEAL}{here}\mdline{24}).%mdk
%mdk
\end{itemize}%mdk

%mdk-data-line={26}
\noindent\mdline{26}My initial plan was to use Lattigo as \mdline{26}\mdcode{golang}\mdline{26} is more widely used in distributed systems. However after installed Lattigo and played with the samples a little bit, I found that the documentation is not that good and I felt a little bit confused with their APIs. Also, I felt I hadn\mdline{26}'\mdline{26}t written \mdline{26}\mdcode{C++}\mdline{26} for a while so it might be a good idea to take a look at the \mdline{26}\mdcode{C++}\mdline{26} libraries. I studied Palisade, SEAL, and HElib and found their APIs to be generally similar. When building and installing Palisade, I met some problems that I couldn\mdline{26}'\mdline{26}t resolve so I moved on to Microsoft SEAL. It has the best documentation (inline comments in source code) from my perspective as well. The installation process was non-trivial and interesting as I have never systematically used CMake and 3rd party libraries for C++ in the past. But fortunately everything worked well.%mdk

%mdk-data-line={28}
\section{\mdline{28}2.\hspace*{0.5em}\mdline{28}Implementation}\label{sec-implementation}%mdk%mdk

%mdk-data-line={30}
\noindent\mdline{30}The application simulates the situation where an anonymous rider needs to find the closest driver around to pick her up, hinted by the\mdline{30}~\href{https://github.com/ldsec/lattigo/blob/master/examples/bfv/main.go}{sample code}\mdline{30} of Lattigo\mdline{30}~[\mdcite{lattigo}{1}]\mdline{30}. On top of it, batching and serialization is ultized. The locations of the rider and drivers are represented as points in a rectangular grid. Server knows that the rider and some drivers are located within this area (this grid), but should not know their exact coordinates.%mdk

%mdk-data-line={32}
\mdline{32}I strongly recommend to read the well-commented source code and run the application to see the output report for more details.%mdk

%mdk-data-line={34}
\subsection{\mdline{34}2.1.\hspace*{0.5em}\mdline{34}Workflow}\label{sec-workflow}%mdk%mdk

%mdk-data-line={36}
\noindent\mdline{36}The application is simulating the sense of server-client communications of real rider-driver pairing applications with two shared streams among users (drivers, rider) and servers for data (ciphertext, public key) and parameter settings.%mdk

%mdk-data-line={38}
\mdline{38}The workflow in general is:%mdk

%mdk-data-line={40}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={40}
\item\mdline{40}The server publishes and sets the parameters of the FHE context;%mdk

%mdk-data-line={41}
\item\mdline{41}The rider follows the parameters and generated a pair of \mdline{41}\mdcode{pk}\mdline{41} and \mdline{41}\mdcode{sk}\mdline{41}, then she uses her \mdline{41}\mdcode{sk}\mdline{41} to symmetrically encrypt her coordinates and send \mdline{41}\mdcode{pk}\mdline{41} and the ciphertext to the server;%mdk

%mdk-data-line={42}
\item\mdline{42}The server broadcasts her pk to all the drivers in this region;%mdk

%mdk-data-line={43}
\item\mdline{43}Drivers encrypt their own coordinates with the rider\mdline{43}'\mdline{43}s \mdline{43}\mdcode{pk}\mdline{43} and send them to the server;%mdk

%mdk-data-line={44}
\item\mdline{44}The server evaluates the squared distance between the rider and each of the drivers homomorphically with relinearization after each operation and then send back \mdline{44}\mdcode{result}\mdline{44} to the rider;%mdk

%mdk-data-line={45}
\item\mdline{45}The rider decrypts \mdline{45}\mdcode{result}\mdline{45} with her \mdline{45}\mdcode{sk}\mdline{45}, and identifies the closest driver.%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={47}
%mdk-data-line={48}
\noindent\mdline{48}\textbf{Note}.
\mdline{49}Coordinates of the rider and drivers are randomly generated for each execution.%mdk%mdk

%mdk-data-line={51}
\noindent\mdline{51}The security parameters chosen in Step 1 is:%mdk
\begin{mdtabular}{3}{\dimeval{(\linewidth)/3}}{1ex}%mdk
\begin{tabular}{ccc}\midrule
\multicolumn{1}{|c}{{\bfseries\mdline{54} polynomial modulus degree}}&\multicolumn{1}{|c}{{\bfseries\mdline{54} ciphertext coefficient modulus}}&\multicolumn{1}{|c|}{{\bfseries\mdline{54}plaintext modulus}}\\

\midrule
\multicolumn{1}{|c}{\mdline{56}$N=2^{13}=8192$}&\multicolumn{1}{|c}{\mdline{56}218 (suggested by the helper function)}&\multicolumn{1}{|c|}{\mdline{56}$T=65929217$}\\
\midrule
\end{tabular}\end{mdtabular}

%mdk-data-line={59}
\noindent\mdline{59}A relatively small polynomial modulus was used here for small ciphertext size and faster execution. To support batching, the plaintext modulus \mdline{59}$T$\mdline{59} was chosen to be a prime number congruent to 1 modulo 2\mdline{59}*\mdline{59}poly\mdline{59}\_\mdline{59}modulus\mdline{59}\_\mdline{59}degree (\mdline{59}$T = 65929217$\mdline{59} specifically here).%mdk

%mdk-data-line={61}
\subsection{\mdline{61}2.2.\hspace*{0.5em}\mdline{61}Batching}\label{sec-batching}%mdk%mdk

%mdk-data-line={63}
\noindent\mdline{63}As hinted by the documentation of SEAL\mdline{63}~[\mdcite{sealcrypto}{2}]\mdline{63}, I used batching for full utilization of the the plaintext polynomial.  The total size of the batching vector is exactly the polynomial modulus degree \mdline{63}$N$\mdline{63}.%mdk

%mdk-data-line={65}
\mdline{65}In Step 2, the plaintext that the rider is encrypting is not a single pair of her coordinates (rider\mdline{65}\_\mdline{65}x, rider\mdline{65}\_\mdline{65}y), but in the format of%mdk
\noindent\noindent\[%mdk-data-line={67}
[rider_x, rider_y, rider_x, rider_y, ... ,rider_x, rider_y].
\]%mdk
\noindent\mdline{69}Accordingly, in step 4, each driver is encrypting its coordinates in the format where for \mdline{69}$i$\mdline{69}-th driver, all coordinates are zero except (\mdline{69}$2i$\mdline{69})-th and (\mdline{69}$2i$\mdline{69}+1)-th coordinates. For example, for driver\mdline{69}{}[\mdline{69}1\mdline{69}]\mdline{69}, it looks like:
\noindent\noindent\[%mdk-data-line={71}
[0, 0, driver[1]_x, driver[1]_y, ... , 0, 0].
\]%mdk
\noindent\mdline{75}Under this setup, in Step 5, the server just need to evaluate the summation of all drivers\mdline{75}'\mdline{75} ciphertexts and substract the rider\mdline{75}'\mdline{75}s ciphertext from it, which gives a ciphertext which can be decrypted to:
\noindent\noindent\[%mdk-data-line={77}
[driver[0]_x - rider_x, driver[0]_y - rider_y, driver[1]_x - rider_x, driver[1]_y - rider_y, ... ]
\]%mdk
\noindent\mdline{79}, and then apply square inplace to obtain the evaluation ciphertext \mdline{79}\mdcode{result}\mdline{79}.

%mdk-data-line={81}
\mdline{81}Therefore, computing \mdline{81}\mdcode{result'{}[2i]+result'{}[2i+1]}\mdline{81}, the distance between the rider and \mdline{81}$i$\mdline{81}-th driver can be obtained  immediately after the decryption (gives \mdline{81}\mdcode{result'}\mdline{81}). The rider then can find the closest driver easily.%mdk

%mdk-data-line={83}
%mdk-data-line={84}
\noindent\mdline{84}\textbf{Note}.
\mdline{85}Because of the limitation of batching slots available, We can have at most \mdline{85}$N/2$\mdline{85} drivers.%mdk%mdk

%mdk-data-line={87}
\subsection{\mdline{87}2.3.\hspace*{0.5em}\mdline{87}Serialization and Communication Channel}\label{sec-serialization-and-communication-channel}%mdk%mdk

%mdk-data-line={89}
\noindent\mdline{89}I didn\mdline{89}'\mdline{89}t write a pair of client-server applications, but used two shared streams to simulate the communication between client and server. It can be transformed to two client-side and server-side applications with minimum efforts by replacing the dummy streams used here with a real data transfer stream for \mdline{89}\mdcode{TCP/UDP}\mdline{89}.%mdk

%mdk-data-line={91}
\begin{itemize}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={91}
\item\mdline{91}\mdcode{parm\_stream:}\mdline{91} used by the server to pass the parameters setting to clients.%mdk

%mdk-data-line={92}
\item\mdline{92}\mdcode{data\_stream:}\mdline{92} used by servers and clients to exchange public keys, linearization keys, and ciphertexts.%mdk
%mdk
\end{itemize}%mdk

%mdk-data-line={95}
\noindent\mdline{95}To optimize the communication package size transferred, I took use of serialization of the SEAL objects. Public keys, relinearization keys, symmetric encrypted ciphertexts in SEAL can all be serialized to have better space efficiency. However, public-key encrypted ciphertexts cannot be serialized. Therefore it is preferred to use the symmetric encryption if possible. That\mdline{95}'\mdline{95}s why in Step 3, the rider is using her \mdline{95}\mdcode{sk}\mdline{95} rather than \mdline{95}\mdcode{pk}\mdline{95} to do the encryption.%mdk

%mdk-data-line={97}
\subsection{\mdline{97}2.4.\hspace*{0.5em}\mdline{97}Some Notable Observations}\label{sec-some-notable-observations}%mdk%mdk

%mdk-data-line={99}
\noindent\mdline{99}Here are some interesting findings that I observed when playing with my application:%mdk

%mdk-data-line={101}
\begin{enumerate}[noitemsep,topsep=\mdcompacttopsep]%mdk

%mdk-data-line={101}
\item\mdline{101}The documentation of SEAL claims that the library built with \mdline{101}\mdcode{clang++}\mdline{101} can run significantly faster than the one built with \mdline{101}\mdcode{g++}\mdline{101}. But my program linked with them respectively does not show much difference given a relatively long execution time \mdline{101}\textasciitilde{}\mdline{101}15s.%mdk

%mdk-data-line={102}
\item\mdline{102}The noise budget remaining in the result ciphertext does not change much from maximum number of drivers (96 bits) i.e. \mdline{102}$N/2$\mdline{102} drivers to 3 drivers (101 bits).%mdk

%mdk-data-line={103}
\item\mdline{103}The noise budget remaining in the result ciphertext does not change at all with or without relinearization after the additions and square operation. I can\mdline{103}'\mdline{103}t explain this well.%mdk

%mdk-data-line={104}
\item\mdline{104}A smaller plaintext modulus gives more remaining noise budget but has no impact on the overall running time.%mdk

%mdk-data-line={105}
\item\mdline{105}A smaller polynomial modulus degree i.e. \mdline{105}$N=4096$\mdline{105} with maximum drivers configured gives a much faster running speed from 15s to 2.5s, while at the cost of a much smaller remaining noise budget from 96 bits to 8 bits.%mdk
%mdk
\end{enumerate}%mdk

%mdk-data-line={108}
\section{\mdline{108}3.\hspace*{0.5em}\mdline{108}Conclusion}\label{sec-conclusion}%mdk%mdk

%mdk-data-line={110}
\noindent\mdline{110}In this project, I experienced how to use a FHE library to implement an application with FHE in practice. I better understood the knowledge in lectures and learned how to play with 3rd party libraries in C++. I implemented an application for oblivious riding with batching and serialization.%mdk

%mdk-data-line={113;out/CSE208_Final_Report-bib.bbl.mdk:1}
%mdk-data-line={113;out/CSE208_Final_Report-bib.bbl.mdk:2}
\mdsetrefname{References}%mdk
{\mdbibindent{0}%mdk
\begin{thebibliography}{2}%mdk
\label{sec-bibliography}%mdk

%mdk-data-line={ref.bib:10}
\bibitem{lattigo}\mdbibitemlabel{{}[1]}\textquotedblleft{}Lattigo v2.1.0.\textquotedblright{} Online: \href{http://github.com/ldsec/lattigo}{{\ttfamily http://\hspace{0pt}github.\hspace{0pt}com/\hspace{0pt}ldsec/\hspace{0pt}lattigo}}. Dec. 2020. EPFL-LDS.\label{lattigo}%mdk%mdk

%mdk-data-line={ref.bib:1}
\bibitem{sealcrypto}\mdbibitemlabel{{}[2]}\textquotedblleft{}Microsoft SEAL (release 3.6).\textquotedblright{} \href{https://github.com/Microsoft/SEAL}{{\ttfamily https://\hspace{0pt}github.\hspace{0pt}com/\hspace{0pt}Microsoft/\hspace{0pt}SEAL}}. Nov. 2020. Microsoft Research, Redmond, WA.\label{sealcrypto}%mdk%mdk
\par%mdk
\end{thebibliography}}%mdk%mdk%mdk


\end{document}
